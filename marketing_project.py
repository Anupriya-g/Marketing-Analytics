# -*- coding: utf-8 -*-
"""marketing project.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ZMbAX0MBpQQIE16RUhXwWTbOIIz2bMBz
"""

# Importing libraries
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

"""# CHURN ANALYSIS"""

# Importing dataset
df = pd.read_csv('/content/drive/MyDrive/internet_service_churn.csv')
df.head()

df.shape

df.info()

df['churn'].value_counts()

plt.figure(figsize=(5,4))
sns.countplot(data=df,x='churn',palette='Set2',hue='churn',legend=False)
plt.show()

"""In this dataset, most of the customers has already cancelled their subscription."""

fig,axes=plt.subplots(1,2,figsize=(8,5))
sns.countplot(data=df,x='is_tv_subscriber',hue='churn',palette='husl',ax=axes[0])
axes[0].set_title("TV Subscription")
sns.countplot(data=df,x='is_movie_package_subscriber',hue='churn',palette='hls',ax=axes[1])
axes[1].set_title('Movie Package Subscription')
fig.tight_layout()

"""From the first figure, it can be interpreted that those who have TV subscription are less likely to churn.
From the second figure, it can be interpreted that those who do not have movie package subscription are more likely to churn.
"""

plt.figure(figsize = (8,6))
sns.countplot(data=df,x='service_failure_count',hue='service_failure_count',legend=False,palette='Set1')
plt.title('Call for Service')
plt.show()

"""It can be inferred from the figure that most of the customers haven't made a call for service in the last 3 months."""

plt.figure(figsize = (12,8))
sns.heatmap(df.corr(),annot= True,fmt='.2f',cmap= 'YlGnBu')
plt.show()

"""Remaining contract period and churn rate are the highly correlated variables. This means that customers with higher value of remaining_contract period is less likely to cancel the subscription."""

df.isnull().sum()

df['reamining_contract'].fillna(df['reamining_contract'].mean(),inplace=True)
df['download_avg'].fillna(df['download_avg'].mean(),inplace=True)
df['upload_avg'].fillna(df['upload_avg'].mean(),inplace=True)

df.drop('id',axis=1,inplace=True)

x = df.iloc[:,:-1]
y = df.iloc[:,-1]

x.shape

from sklearn.preprocessing import StandardScaler
sc=StandardScaler()
x=sc.fit_transform(x)

from sklearn.model_selection import train_test_split
x_train,x_test,y_train,y_test=train_test_split(x,y,test_size=0.2,random_state=0)

from sklearn.linear_model import LogisticRegression
logr=LogisticRegression()
logr.fit(x_train,y_train)
y_pred=logr.predict(x_test)

from sklearn.metrics import accuracy_score,precision_score,recall_score,f1_score
lr_acc=accuracy_score(y_test,y_pred)
lr_prec=precision_score(y_test,y_pred)
lr_rec=recall_score(y_test,y_pred)
lr_f1=f1_score(y_test,y_pred)

from sklearn.neighbors import KNeighborsClassifier
knn=KNeighborsClassifier(n_neighbors=10)
knn.fit(x_train, y_train)
y_pred=knn.predict(x_test)

knn_acc=accuracy_score(y_test,y_pred)
knn_prec=precision_score(y_test,y_pred)
knn_rec=recall_score(y_test,y_pred)
knn_f1=f1_score(y_test,y_pred)

from sklearn.tree import DecisionTreeClassifier
dtc=DecisionTreeClassifier(criterion='entropy',splitter='random')
dtc.fit(x_train,y_train)
y_pred=dtc.predict(x_test)

dtc_acc=accuracy_score(y_test,y_pred)
dtc_prec=precision_score(y_test,y_pred)
dtc_rec=recall_score(y_test,y_pred)
dtc_f1=f1_score(y_test,y_pred)

from sklearn.ensemble import RandomForestClassifier
rf=RandomForestClassifier(n_estimators=10,criterion='entropy')
rf.fit(x_train, y_train)
y_pred=rf.predict(x_test)

rf_acc=accuracy_score(y_test,y_pred)
rf_prec=precision_score(y_test,y_pred)
rf_rec=recall_score(y_test,y_pred)
rf_f1=f1_score(y_test,y_pred)

perf={'Accuracy':[lr_acc, knn_acc, dtc_acc, rf_acc],
      'Precision':[lr_prec, knn_prec, dtc_prec, rf_prec],
      'Recall': [lr_rec, knn_rec, dtc_rec, rf_rec]}
perf_df = pd.DataFrame(data=perf, index= ['Logistic Regression', 'KNeighbors','DecisionTree', 'RandomForest',])
perf_df

"""### **INTERPRETATION**



*   Customers with higher value of remaining_contract period is less likely to cancel the subscription.


*    Those who have TV subscription are less likely to churn.


*  Those who do not have movie package subscription are more likely to churn.


*   Random forest model has the highest accuracy (94% approx.)
in predicting the churn of customers.

# PRICE ANALYTICS
"""

df=pd.read_csv('/content/drive/MyDrive/diamonds.csv')
df.head()

df.shape

df.info()

df.drop("Unnamed: 0",axis=1,inplace=True)

sns.barplot(data=df,x='cut',y='price',hue='cut',legend=False,palette='husl')
plt.show()

"""Premium cut diamonds are sold at a higher price than the others."""

numeric=df.select_dtypes(exclude=object).columns
data=df[numeric].corr()
sns.heatmap(data,annot=True)

"""The price of the diamond highly depends on the carat."""

from sklearn.preprocessing import LabelEncoder
le=LabelEncoder()
df['cut']=le.fit_transform(df['cut'])
df['color']=le.fit_transform(df['color'])
df['clarity']=le.fit_transform(df['clarity'])

x=df.drop('price',axis=1)
y=df['price']

from sklearn.preprocessing import StandardScaler
sc=StandardScaler()
x=sc.fit_transform(x)

from sklearn.model_selection import train_test_split
x_train,x_test,y_train,y_test=train_test_split(x,y,test_size=0.2,random_state=0)

from sklearn.linear_model import LinearRegression
lr=LinearRegression()
lr.fit(x_train,y_train)
y_pred=lr.predict(x_test)

from sklearn.metrics import mean_absolute_error,mean_squared_error,r2_score
lr_mse=mean_squared_error(y_test,y_pred)
lr_mae=mean_absolute_error(y_test,y_pred)
lr_r2=r2_score(y_test,y_pred)

from sklearn.tree import DecisionTreeRegressor
dtr=DecisionTreeRegressor()
dtr.fit(x_train,y_train)
y_pred=dtr.predict(x_test)

dtr_mse=mean_squared_error(y_test,y_pred)
dtr_mae=mean_absolute_error(y_test,y_pred)
dtr_r2=r2_score(y_test,y_pred)

from sklearn.ensemble import RandomForestRegressor
rfr=RandomForestRegressor()
rfr.fit(x_train,y_train)
y_pred=rfr.predict(x_test)

rfr_mse=mean_squared_error(y_test,y_pred)
rfr_mae=mean_absolute_error(y_test,y_pred)
rfr_r2=r2_score(y_test,y_pred)

perf={'MAE':[lr_mae, dtr_mae, rfr_mae],
      'MSE':[lr_mse, dtr_mse, rfr_mse],
      'R2': [lr_r2, dtr_r2, rfr_r2]}
perf_df = pd.DataFrame(data=perf, index= ['Linear Regression','DecisionTree', 'RandomForest'])
perf_df

"""### **INTERPRETATION**



*   Premium cut diamonds are sold at a higher price than the others.


*   The price of the diamond highly depends on the carat.


*   Random Forest Regressor is better in predicting the price of the diamond with an accuracy of 98% approx.




"""

